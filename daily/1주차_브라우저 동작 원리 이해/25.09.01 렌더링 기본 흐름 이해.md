### 오늘의 목표

- 브라우저가 코드를 화면에 그리는 과정을 이해한다.

### 학습 내용 정리

- 랜더링 기본 흐름
	- HTML 파싱 → DOM 생성
	- CSS 파싱 → CCOM 생성
	- DOM + CSSOM → 스타일 계산 → Render Tree
	- Layout
	- Paint
	- Composite
	
##### 1. 브라우저가 HTML을 읽는 과정(HTML 파싱 → DOM 생성)
1. 브라우저는 서버에서 HTML 문서를 받아오면 **byte stream**(바이트 스트림) 상태로 저장합니다.
2. 이 스트림을 **문자셋(UTF-8 등)에 따라 문자**로 디코딩합니다.
3. 문자를 **토큰(token)** 으로 쪼갭니다.
	- `<html>`, `<body>`, `<div>` 같은 태그 시작/끝, 속성, 텍스트 등으로 분리.
4. 토큰들을 이용해 **노드(node)** 객체를 생성합니다.
5. 이 노드들이 계층 구조를 이루며 **DOM 트리(Document Object Model Tree)** 가 만들어집니다.
```HTML
<!DOCTYPE html>
<html>
  <head>
    <title>Hello</title>
  </head>
  <body>
    <h1 id="title">Hi</h1>
    <p>Paragraph</p>
  </body>
</html>
```

```less
Document
 └── html
      ├── head
      │     └── title ("Hello")
      └── body
            ├── h1#title ("Hi")
            └── p ("Paragraph")
```


##### 2. CSS 파싱 → CSSOM 생성
1.  `<link rel="stylesheet" href="style.css">`, `<style>…</style>`, `@import` 등을 만나면 CSS 리소스를 로드
	1. DOM은 만들어지더라도, 최종 그리기 전에 CSS 파싱이 끝나야 정확한 레이아웃을 계산할 수 있어서 외부 스타일시트는 보통 **렌더링을 잠시 멈추게**(render-blocking) 함.
	2. `@import`는 해당 파일을 **추가로 로드**시켜 지연을 늘릴 수 있으니, 실무에선 가능하면 `<link>`를 권장
2. CSS는 선택자와 규칙을 해석해 CSSOM(CSS Object Model)을 만든다. (DOM과 동일한 과정을 거침)
```css
h1 {
  color: red;
  font-size: 20px;
}

.card {
  background: #eee;
}

@media (max-width: 600px) {
  .card {
    background: #ccc;
  }
}
```

```less
CSSStyleSheet
 ├── CSSStyleRule (selector: "h1")
 │     ├── property: color → "red"
 │     └── property: font-size → "20px"
 │
 ├── CSSStyleRule (selector: ".card")
 │     └── property: background → "#eee"
 │
 └── CSSMediaRule (@media (max-width: 600px))
       └── CSSStyleRule (selector: ".card")
             └── property: background → "#ccc"
```

##### 3. DOM + CSSOM → 스타일 계산 → Render Tree 생성
1. 스타일 계산
	1. CSS 우선순위와 코드를 해석하여, computed style을 만듦
	2. 계산 순서
		- **규칙 매칭**: DOM 각 노드에 대해 CSS 선택자 규칙 매칭
		- **Cascade(카스케이딩)**: 우선순위 적용
			- 출처(user-agent < 사용자 < 작성자)
			- !important
			- 특이성(specificity: id > class > 태그)
			- 선언 순서(나중에 나온 게 이김)
		- **Inheritance(상속)**: 일부 속성은 부모에서 자식에게 상속 (`color`, `font-family` 등)
		- **변수 해석**: `var(--primary-color)` 같은 CSS 변수 값 대입
		- **값 계산 단계**
2. Render Tree 생성
	- DOM + Computed Style을 합쳐 **Render Tree**를 만듭니다.
	- `display:none` 요소는 제외됨 (렌더링 대상 아님).
	- `visibility:hidden` 요소는 Render Tree에 포함되지만, **보이지 않게 Paint** 처리됨.
##### 4. Layout(Reflow) 단계
- Render Tree 노드들의 **위치(x, y)** 와 **크기(width, height)** 를 계산
- 브라우저의 뷰포트 크기, 부모-자식 관계, CSS 속성(`display`, `position`, `flex`, `grid` 등)에 따라 계산
- DOM 구조(노드 추가/삭제)나 레이아웃 관련 CSS 변경 시 다시 실행됨
	- `width`, `height`, `margin`, `padding`, `border`, `font-size`, `position`, `top/left` 등
- 성능 비용이 크므로 최소화하는 것이 중요
	- Layout은 **연쇄적** 영향을 미치기에 한 요소의 크기 변경이 전체 문서 레이아웃을 다시 계산하게 만들 수 있음.
※ 최적화 팁
1. DOM 변경은 한 번에 모아서 하기
```js
// bad : 매 줄마다 Reflow 발생 가능
const box = document.getElementById("box");
box.style.width = "100px";
box.style.height = "100px";
box.style.margin = "20px";

// good 1 : 한 번에 스타일 변경 → Reflow 1번만 발생
const box = document.getElementById("box");
box.style.cssText = "width:100px; height:100px; margin:20px;";

// good 2 : 미리 정의한 CSS 클래스 한 번에 적용
box.classList.add("big-box"); 
```

2. 읽기와 쓰기 작업을 섞지 말기 (Layout Thrashing 방지)
- DOM에서 크기/위치 같은 속성을 읽을 때도 **강제로 Reflow** 가 발생합니다.
```js
// bad : 읽기(offsetWidth) → 쓰기(style.width) → 다시 읽기(offsetHeight)…
const el = document.getElementById("item");
el.style.width = (el.offsetWidth + 10) + "px";
el.style.height = (el.offsetHeight + 10) + "px";

// good : 읽기 다 끝내고, 쓰기 다 나중에 실행 → Reflow 최소화
const el = document.getElementById("item");
const width = el.offsetWidth;
const height = el.offsetHeight;

el.style.width = (width + 10) + "px";
el.style.height = (height + 10) + "px";
```

3. 애니메이션은 transform / opacity 사용하기
- `width`, `height`, `top`, `left` 변경 = Layout(Reflow) + Paint 발생 → 무거움
- `background-color`, `color` 변경 = Paint만 발생 → 조금 덜 무거움
- `transform: translateX()`, `opacity` 변경 = **Composite 단계에서만 처리** → GPU 가속 활용 → 제일 가벼움

##### 5. Paint 단계
- 색상, 텍스트, 그림자 등 실제 픽셀을 채움
- `color`, `background`, `box-shadow`  등 요소 크기/위치(Layout)에 영향을 주지 않는 변경 → Paint만 발생
- `transform`, `opacity`는 Paint를 건너뛰고 **Composite 단계에서만** 처리 가능.
	- 애니메이션은 `transform: translate/scale/rotate`, `opacity` 위주로 하는 게 좋음.
##### 6. Composite 단계
- paint 단계에서 만들어진 각 요소별 픽셀 그림(레이어)를 **겹치고 순서대로 합쳐서 최종 화면**을 만듭니다.
- 단순히 덮어씌우는 게 아니라, **투명도(opacity), transform(이동/회전/스케일), z-index(쌓임 순서)** 를 고려해 GPU에서 합성

#### 키워드 요약
DOM, CSSOM, Style Calculation, Render Tree, Layout(Reflow), Paint, Composite(GPU)

### 남은 의문/복습할 것

- 브라우저 Dev Tool 쓰는 법
- HTML/CSS/JS가 언제 렌더링을 막는지 (Render Blocking)
	- `@import`는 해당 파일을 **추가로 로드**시켜 지연을 늘릴 수 있으니, 실무에선 가능하면 `<link>`를 권장
- will-change 속성
